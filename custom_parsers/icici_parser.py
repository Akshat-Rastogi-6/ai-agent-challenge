# Auto-generated by agent.py
# Fallback attempt: pdfplumber-based extraction
from __future__ import annotations
import pandas as pd

EXPECTED_COLS = ["Date", "Description", "Debit Amt", "Credit Amt", "Balance"]

def parse(pdf_path: str) -> pd.DataFrame:
    try:
        import pdfplumber  # type: ignore
    except Exception as e:
        raise ImportError("pdfplumber not installed or failed to import") from e

    rows = []
    with pdfplumber.open(pdf_path) as pdf:
        for page in pdf.pages:
            for table in page.extract_tables() or []:
                for row in table:
                    rows.append([None if cell is None else str(cell).strip() for cell in row])

    if not rows:
        raise ValueError("No tables extracted via pdfplumber; need tuned parsing")

    raw = pd.DataFrame(rows)
    # Use row 0 as header if textual
    if raw.shape > 1 and all(isinstance(x, str) for x in raw.iloc.tolist()):
        raw.columns = [c.strip() for c in raw.iloc.tolist()]
        raw = raw.iloc[1:].reset_index(drop=True)

    # Enforce expected columns and simple normalization, similar to Camelot template
    for col in EXPECTED_COLS:
        if col not in raw.columns:
            raw[col] = pd.NA
    df = raw[EXPECTED_COLS]

    if "Date" in df.columns:
        try:
            df["Date"] = pd.to_datetime(df["Date"], errors="coerce", dayfirst=True)
        except Exception:
            pass
    for num_col in ["Debit", "Credit", "Amount", "Balance"]:
        if num_col in df.columns:
            df[num_col] = (
                df[num_col]
                .astype(str)
                .str.replace(",", "", regex=False)
                .str.replace("â‚¹", "", regex=False)
                .str.replace("INR", "", regex=False)
            )
            df[num_col] = pd.to_numeric(df[num_col], errors="coerce")

    return df